// app/api/inpaint/nano-banana/route.ts
/**
 * Optimized Nano Banana API with Sharp processing
 * Features:
 * - Memory-efficient image processing
 * - Reference image support (0-3 images)
 * - Expanded context for better results
 * - Smart prompting with natural language
 */

import { MaskBounds } from '@/lib/constants/inpaint';
import { createClient } from '@/lib/supabaseServer';
import {
    bufferToBase64,
    buildNaturalPrompt,
    compositeGeneratedImage,
    cropImageWithContext,
    estimateMemoryUsage,
    expandMaskBounds,
    urlToBase64
} from '@/lib/utils/inpaint/inpaintProcessor';
import { NextRequest, NextResponse } from 'next/server';

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent';

interface RequestBody {
    userId: string;
    imageUrl: string;
    maskBounds: MaskBounds;
    userPrompt: string;
    referenceUrls?: string[]; // Optional reference images
}

export async function POST(request: NextRequest) {
    const startTime = Date.now();

    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('[Nano Banana] Starting optimized processing...');

    try {
        const body: RequestBody = await request.json();
        const { userId, imageUrl, maskBounds, userPrompt, referenceUrls = [] } = body;

        console.log('User ID:', userId);
        console.log('Image URL:', imageUrl);
        console.log('Mask Bounds:', maskBounds);
        console.log('User Prompt:', userPrompt);
        console.log('Reference Images:', referenceUrls.length);

        // Validate inputs
        if (!userId || !imageUrl || !maskBounds || !userPrompt) {
            return NextResponse.json(
                { error: 'Missing required fields' },
                { status: 400 }
            );
        }

        if (referenceUrls.length > 3) {
            return NextResponse.json(
                { error: 'Maximum 3 reference images allowed' },
                { status: 400 }
            );
        }

        // Estimate memory usage for logging
        const memoryEstimate = estimateMemoryUsage(300 * 1024, maskBounds);
        console.log('ğŸ“Š Memory estimate:', memoryEstimate);

        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        // âœ… STEP 1: Expand bounds for context
        const expansionRatio = 0.25; // 25% expansion
        const expandedBounds = expandMaskBounds(maskBounds, expansionRatio);

        console.log('[Step 1] Expanded bounds:', {
            original: `${maskBounds.width}x${maskBounds.height}`,
            expanded: `${expandedBounds.width}x${expandedBounds.height}`,
            expansion: `${Math.round(expansionRatio * 100)}%`
        });

        // âœ… STEP 2: Crop image with context (Sharp - memory efficient!)
        console.log('[Step 2] Cropping with Sharp...');
        const { buffer: croppedBuffer } = await cropImageWithContext(imageUrl, expandedBounds);
        console.log(`âœ… Cropped: ${Math.round(croppedBuffer.length / 1024)}KB`);

        // âœ… STEP 3: Convert to base64 for Gemini
        console.log('[Step 3] Converting to base64...');
        const croppedBase64 = bufferToBase64(croppedBuffer);

        // âœ… STEP 4: Build smart natural language prompt
        console.log('[Step 4] Building smart prompt...');
        const smartPrompt = buildNaturalPrompt(userPrompt, maskBounds, referenceUrls.length);

        console.log('ğŸ“ SMART PROMPT:');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log(smartPrompt);
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        // âœ… STEP 5: Prepare Gemini API request parts
        const parts: any[] = [
            { text: smartPrompt },
            { inline_data: { mime_type: 'image/jpeg', data: croppedBase64 } }
        ];

        // Add reference images if provided
        if (referenceUrls.length > 0) {
            console.log('[Step 5] Adding reference images...');
            for (let i = 0; i < referenceUrls.length; i++) {
                const refBase64 = await urlToBase64(referenceUrls[i]);
                parts.push({
                    inline_data: { mime_type: 'image/jpeg', data: refBase64 }
                });
                console.log(`âœ… Reference ${i + 1} added`);
            }
        }

        // âœ… STEP 6: Call Gemini API
        console.log('[Step 6] Calling Gemini API...');
        const geminiResponse = await fetch(
            `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts }],
                    generationConfig: {
                        temperature: 0.4,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 4096
                    }
                })
            }
        );

        if (!geminiResponse.ok) {
            const errorText = await geminiResponse.text();
            console.error('âŒ Gemini API error:', errorText);
            throw new Error(`Gemini API failed: ${geminiResponse.status}`);
        }

        const geminiData = await geminiResponse.json();
        console.log('âœ… Gemini API responded');
        console.log('Response candidates:', geminiData.candidates?.length || 0);

        // ğŸ”§ DEBUG: Log full Gemini response structure
        console.log('ğŸ“¦ Full Gemini Response:', JSON.stringify(geminiData, null, 2));

        // Extract generated image
        const generatedImageBase64 = geminiData.candidates?.[0]?.content?.parts?.find(
            (part: any) => part.inline_data
        )?.inline_data?.data;

        if (!generatedImageBase64) {
            // ğŸ”§ DEBUG: Log detailed error information
            console.error('âŒ Gemini response structure:', {
                hasCandidates: !!geminiData.candidates,
                candidatesLength: geminiData.candidates?.length,
                firstCandidate: geminiData.candidates?.[0],
                hasContent: !!geminiData.candidates?.[0]?.content,
                parts: geminiData.candidates?.[0]?.content?.parts,
                finishReason: geminiData.candidates?.[0]?.finishReason,
                safetyRatings: geminiData.candidates?.[0]?.safetyRatings
            });
            throw new Error('No image in Gemini response');
        } const generatedBuffer = Buffer.from(generatedImageBase64, 'base64');
        console.log(`âœ… Generated image: ${Math.round(generatedBuffer.length / 1024)}KB`);

        // âœ… STEP 7: Composite back onto original (Sharp!)
        console.log('[Step 7] Compositing with Sharp...');
        const finalBuffer = await compositeGeneratedImage(
            imageUrl,
            generatedBuffer,
            maskBounds // Use ORIGINAL tight bounds for placement
        );
        console.log(`âœ… Final composite: ${Math.round(finalBuffer.length / 1024)}KB`);

        // âœ… STEP 8: Upload to Supabase
        console.log('[Step 8] Uploading to Supabase...');
        const supabase = await createClient();
        const timestamp = Date.now();
        const fileName = `${userId}/inpaint_${timestamp}.jpg`;

        const { data: uploadData, error: uploadError } = await supabase.storage
            .from('renderlab-images')
            .upload(fileName, finalBuffer, {
                contentType: 'image/jpeg',
                upsert: false
            });

        if (uploadError) {
            console.error('âŒ Upload error:', uploadError);
            throw uploadError;
        }

        const { data: { publicUrl } } = supabase.storage
            .from('renderlab-images')
            .getPublicUrl(fileName);

        console.log('âœ… Uploaded:', publicUrl);

        // âœ… STEP 9: Save to database
        console.log('[Step 9] Saving to database...');
        const { data: dbData, error: dbError } = await supabase
            .from('inpaint_edits')
            .insert({
                user_id: userId,
                base_image_url: imageUrl,
                result_image_url: publicUrl,
                mask_bounds: maskBounds,
                user_prompt: userPrompt,
                reference_urls: referenceUrls,
                model: 'gemini-2.5-flash-image',
                processing_time_ms: Date.now() - startTime
            })
            .select()
            .single();

        if (dbError) {
            console.error('âŒ Database error:', dbError);
            // Don't throw - image is already uploaded
        }

        const totalTime = Date.now() - startTime;

        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ğŸ‰ SUCCESS!');
        console.log('Total time:', totalTime, 'ms');
        console.log('Result URL:', publicUrl);
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

        return NextResponse.json({
            success: true,
            url: publicUrl,
            editId: dbData?.id,
            processingTimeMs: totalTime,
            memoryEstimate
        });

    } catch (error: any) {
        const totalTime = Date.now() - startTime;

        console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.error('âŒ ERROR after', totalTime, 'ms');
        console.error(error);
        console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

        return NextResponse.json(
            {
                error: error.message || 'Processing failed',
                processingTimeMs: totalTime
            },
            { status: 500 }
        );
    }
}
